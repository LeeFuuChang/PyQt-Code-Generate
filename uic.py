from util import *

VERSION = "1.0"

setattr(sys, 'kwargv', {sys.argv[idx][2:]:sys.argv[idx+1] for idx in range(len(sys.argv)) if sys.argv[idx].startswith("--")})

UI_XML_PATH = ""
if("ui-path" not in sys.kwargv): 
    for argv in sys.argv:
        if(not argv.endswith(".ui")): continue
        UI_XML_PATH = argv
        break
else: UI_XML_PATH = sys.kwargv["ui-path"]
if(not os.path.exists(UI_XML_PATH)): showErrorAndQuit(f"Could not find UI file at: {UI_XML_PATH}")

UI_XML = ET.parse(UI_XML_PATH)

UI = UI_XML.getroot()

ROOT = UI.find("widget")

HEADER = (
    f"\"\"\"\n"
    f"********************************************************************************\n"
    f"** Code generated by reading UI file: {os.path.basename(UI_XML_PATH)}\n"
    f"**\n"
    f"** UI Version: {UI.attrib['version']}\n"
    f"** Code Generater Version: {VERSION}\n"
    f"**\n"
    f"** WARNING! All changes made in this file will be lost when recompiling UI file!\n"
    f"********************************************************************************\n"
    f"\"\"\"\n"
)






def recursedOneDir(root, path):
    childNames = []
    childSignals = []
    for child in root:
        if(child.tag != "widget"): continue
        className = child.attrib["class"]
        widgetName = child.attrib["name"]
        widgetPath = os.path.join(path, widgetName)

        if(not os.path.exists(widgetPath)): os.mkdir(widgetPath)
        childNames.append(widgetName)

        signals = classSignals.get(className, [])
        content = ""
        for signal in signals:
            content += f"# CLASS {className} SIGNAL {signal[1]} FROM {signal[2]}\n"
            content += f"def on_{signal[1]}():\n"
            content += f"    print(\"{widgetName} {signal[1]}\")\n"
            content += "\n\n\n"
            childSignals.append([widgetName, signal[1], f"{widgetName}.on_{signal[1]}"])
        with open(os.path.join(widgetPath, "__init__.py"), "w") as f: f.write(content)
        childSignals.extend([childWidgetName, signalName, f"{widgetName}.{signalPath}"] for childWidgetName, signalName, signalPath in recursedOneDir(child, widgetPath))
    rootImportContent = "\n".join([f"from . import {name}" for name in childNames])
    with open(os.path.join(path, "__init__.py"), "r") as f: rootContent = f.read()
    neededSpacing = (rootImportContent != "" and rootContent != "")*6
    with open(os.path.join(path, "__init__.py"), "w") as f: f.write(rootImportContent + "\n"*neededSpacing + rootContent)
    return childSignals


def buildOneDir(root, dist):
    if(not os.path.exists(dist)): return False

    windowTitle = root.attrib["name"]
    for child in root: 
        if(child.tag == "property" and child.attrib["name"] == "windowTitle"):
            windowTitle = child.find("string").text
    rootClassName = windowTitle

    with open(os.path.join(dist, "main.py"), "w") as f:
        f.write(
            f"{HEADER}\n"
            f"\n"
            f"from PyQt5.QtWidgets import QApplication\n"
            f"\n"
            f"import sys\n"
            f"\n"
            f"from {windowTitle} import {rootClassName}\n"
            f"\n"
            f"\n"
            f"\n"
            f"def main():\n"
            f"    app = QApplication(sys.argv)\n"
            f"    ui = {rootClassName}()\n"
            f"    ui.show()\n"
            f"    sys.exit(app.exec_())\n"
            f"\n"
            f"if __name__ == \"__main__\":\n"
            f"    main()\n"
        )

    dist = os.path.join(dist, windowTitle)
    if(not os.path.exists(dist)): os.mkdir(dist)

    with open(os.path.join(dist, "__init__.py"), "w") as f: f.write("")

    rootImportContent = (
        f"from PyQt5.QtWidgets import {root.attrib['class']}\n"
        f"from PyQt5 import uic\n"
    )

    rootClassDefinition = (
        f"class {rootClassName}({root.attrib['class']}):\n"
        f"    def __init__(self):\n"
        f"        super(self.__class__, self).__init__()\n"
        f"        uic.loadUi(r\"{UI_XML_PATH}\", self)\n"
    )
    prevWidgetName = ""
    for widgetName, signalName, signalPath in recursedOneDir(root, dist):
        if(prevWidgetName != widgetName): rootClassDefinition += "\n"
        rootClassDefinition += f"        self.{widgetName}.{signalName}.connect({signalPath})\n"
        prevWidgetName = widgetName

    with open(os.path.join(dist, "__init__.py"), "r") as f: rootFileContent = f.read()
    neededSpacing = (rootFileContent != "" and rootClassDefinition != "")*6
    with open(os.path.join(dist, "__init__.py"), "w") as f: 
        f.write(
            rootImportContent + "\n" + 
            rootFileContent + "\n"*neededSpacing + 
            rootClassDefinition
        )
    return True

# buildOneDir(ROOT, r"C:\Users\a0962\Desktop\QtGenerate\output")





def recursedCodeView(root, content):
    childNames = []
    childSignals = {}
    for child in root:
        if(child.tag != "widget"): continue
        className = child.attrib["class"]
        widgetName = child.attrib["name"]

        childNames.append(widgetName)
        childSignals[widgetName] = []

        signals = classSignals.get(className, [])
        if(signals): content += "\n\n\n"
        for signal in signals:
            funcName = f"{widgetName}_on_{signal[1]}"
            content += f"    # CLASS {className} SIGNAL {signal[1]} FROM {signal[2]}\n"
            content += f"    def {funcName}(self, *args, **kwargs):\n"
            content += f"        print(\"{widgetName} {signal[1]}\")\n"
            content += f"        print(\"arguments:\", args)\n"
            content += f"        print(\"keyword args:\", kwargs)\n"
            content += f"\n"
            childSignals[widgetName].append([signal[1], funcName])
        grandSignals, content = recursedCodeView(child, content)
        childSignals.update(grandSignals)
    return childSignals, content


def buildCodeView(root):
    windowTitle = root.attrib["name"]
    for child in root: 
        if(child.tag == "property" and child.attrib["name"] == "windowTitle"):
            windowTitle = child.find("string").text
    rootClassName = windowTitle

    contentBeg = (
        f"from PyQt5.QtWidgets import QApplication, {root.attrib['class']}\n"
        f"from PyQt5 import uic\n"
        f"\n"
        f"import sys\n"
        f"\n"
        f"\n"
        f"\n"
        f"class {rootClassName}({root.attrib['class']}):\n"
        f"    def __init__(self):\n"
        f"        super(self.__class__, self).__init__()\n"
        f"        uic.loadUi(r\"{UI_XML_PATH}\", self)\n"
    )
    contentEnd = (
        f"\n"
        f"\n"
        f"\n"
        f"\n"
        f"\n"
        f"def main():\n"
        f"    app = QApplication(sys.argv)\n"
        f"    ui = {rootClassName}()\n"
        f"    ui.show()\n"
        f"    sys.exit(app.exec_())\n"
        f"\n"
        f"if __name__ == \"__main__\":\n"
        f"    main()\n"
    )

    childSignals, signalContent = recursedCodeView(root, "")

    connectContent = ""
    for widgetName, signalFuncNames in childSignals.items():
        connectContent += f"\n"
        connectContent += f"        # CONNECT {widgetName} SIGNALS\n"
        for signalName, funcName in signalFuncNames:
            connectContent += f"        self.{widgetName}.{signalName}.connect(self.{funcName})\n"

    codeContent = HEADER + contentBeg + connectContent + signalContent + contentEnd

    print(codeContent)

    # with open("output.py", "w") as f: f.write(codeContent)


buildCodeView(ROOT)









